// background.js (MV3 service worker)
// Mantém estado do timer e dispara notificações ao término.

const DEFAULT_DURATION_SEC = 25 * 60; // 25 minutos
const STORAGE_KEY = "timerState";
const ALARM_NAME = "timerEnd";

// Estrutura do estado:
// { isRunning: boolean, remainingSec: number, targetTime: number | null }

chrome.runtime.onInstalled.addListener(async () => {
  const current = await loadState();
  if (!current) {
    await saveState({
      isRunning: false,
      remainingSec: DEFAULT_DURATION_SEC,
      targetTime: null
    });
  }
});

chrome.runtime.onMessage.addListener((msg, sender, sendResponse) => {
  (async () => {
    if (msg?.type === "TIMER_GET_STATE") {
      const state = await getFreshState();
      sendResponse({ ok: true, state });
    }

    if (msg?.type === "TIMER_START") {
      const state = await getFreshState();
      if (!state.isRunning && state.remainingSec > 0) {
        const now = Date.now();
        state.isRunning = true;
        state.targetTime = now + state.remainingSec * 1000;
        chrome.alarms.create(ALARM_NAME, { when: state.targetTime });
        await saveState(state);
      }
      sendResponse({ ok: true });
    }

    if (msg?.type === "TIMER_PAUSE") {
      const state = await getFreshState();
      if (state.isRunning) {
        state.remainingSec = calcRemainingSec(state);
        state.isRunning = false;
        state.targetTime = null;
        await chrome.alarms.clear(ALARM_NAME);
        await saveState(state);
      }
      sendResponse({ ok: true });
    }

    if (msg?.type === "TIMER_RESET") {
      const state = await getFreshState();
      state.isRunning = false;
      state.remainingSec = DEFAULT_DURATION_SEC;
      state.targetTime = null;
      await chrome.alarms.clear(ALARM_NAME);
      await saveState(state);
      sendResponse({ ok: true });
    }

    if (msg?.type === "TIMER_SET_MINUTES") {
      const minutes = Number(msg.minutes);
      const secs = Math.max(1, Math.round(minutes * 60));
      const state = await getFreshState();
      state.isRunning = false;
      state.remainingSec = secs;
      state.targetTime = null;
      await chrome.alarms.clear(ALARM_NAME);
      await saveState(state);
      sendResponse({ ok: true });
    }
  })();
  return true; // indica que vamos responder assíncronamente
});

chrome.alarms.onAlarm.addListener(async (alarm) => {
  if (alarm.name !== ALARM_NAME) return;
  const state = await getFreshState();
  state.isRunning = false;
  state.remainingSec = 0;
  state.targetTime = null;
  await saveState(state);

  try {
    await chrome.notifications.create({
      type: "basic",
      iconUrl: "icon.png",
      title: "Tempo concluído",
      message: "Ciclo de foco finalizado. Faça uma pausa 👏",
      priority: 2
    });
  } catch (e) {
    // ignorar falhas em notificação (usuário pode ter bloqueado)
  }
});

// Helpers
async function loadState() {
  const obj = await chrome.storage.local.get(STORAGE_KEY);
  return obj[STORAGE_KEY];
}

async function saveState(state) {
  await chrome.storage.local.set({ [STORAGE_KEY]: state });
}

function calcRemainingSec(state) {
  if (!state.isRunning || !state.targetTime) return state.remainingSec ?? DEFAULT_DURATION_SEC;
  const diff = Math.max(0, Math.round((state.targetTime - Date.now()) / 1000));
  return diff;
}

async function getFreshState() {
  let state = await loadState();
  if (!state) {
    state = { isRunning: false, remainingSec: DEFAULT_DURATION_SEC, targetTime: null };
    await saveState(state);
  }
  if (state.isRunning && state.targetTime) {
    const fresh = calcRemainingSec(state);
    if (fresh === 0) {
      state.isRunning = false;
      state.remainingSec = 0;
      state.targetTime = null;
      await chrome.alarms.clear(ALARM_NAME);
      await saveState(state);
    } else {
      state = { ...state, remainingSec: fresh };
    }
  }
  return state;
}

// Lista de sites para bloquear
const blockedSites = [
  "*://*.facebook.com/*",
  "*://*.instagram.com/*",
  "*://*.tiktok.com/*",
  "*://*.twitter.com/*",
  "*://*.x.com/*",
  "*://*.youtube.com/*"
];

// Cria regras de bloqueio
const rules = blockedSites.map((site, index) => ({
  id: index + 1,
  priority: 1,
  action: { type: "block" },
  condition: { urlFilter: site }
}));

// Função para atualizar regras
async function applyRules() {
  try {
    await chrome.declarativeNetRequest.updateDynamicRules({
      removeRuleIds: rules.map(rule => rule.id),
      addRules: rules
    });
    console.log("✅ Regras aplicadas:", blockedSites);
  } catch (error) {
    console.error("❌ Erro ao aplicar regras:", error);
  }
}

// Executa quando o service worker inicia
chrome.runtime.onInstalled.addListener(() => {
  applyRules();
});

chrome.runtime.onStartup.addListener(() => {
  applyRules();
});
